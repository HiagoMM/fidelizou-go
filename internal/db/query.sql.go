// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getMyFidelityCards = `-- name: GetMyFidelityCards :many
SELECT
    fidelity_card.id,
    fidelity_card.points,
    fidelity_card.dates_of_uses,
    fidelity_card.program_id,
    fidelity_card.created_at,
    program.title,
    program.description,
    program.fidelity_card_front_image,
    program.fidelity_card_back_image,
    program.fidelity_card_point_image,
    program.fidelity_card_max_points,
    program.final_date
FROM "fidelity_card"
INNER JOIN "program" ON fidelity_card.program_id = program.id
WHERE fidelity_card.user_id = $1
`

type GetMyFidelityCardsRow struct {
	ID                     int32
	Points                 pgtype.Int4
	DatesOfUses            pgtype.Timestamp
	ProgramID              pgtype.Int4
	CreatedAt              pgtype.Timestamp
	Title                  pgtype.Text
	Description            pgtype.Text
	FidelityCardFrontImage pgtype.Text
	FidelityCardBackImage  pgtype.Text
	FidelityCardPointImage pgtype.Text
	FidelityCardMaxPoints  pgtype.Int4
	FinalDate              pgtype.Timestamp
}

func (q *Queries) GetMyFidelityCards(ctx context.Context, userID pgtype.Int4) ([]GetMyFidelityCardsRow, error) {
	rows, err := q.db.Query(ctx, getMyFidelityCards, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMyFidelityCardsRow
	for rows.Next() {
		var i GetMyFidelityCardsRow
		if err := rows.Scan(
			&i.ID,
			&i.Points,
			&i.DatesOfUses,
			&i.ProgramID,
			&i.CreatedAt,
			&i.Title,
			&i.Description,
			&i.FidelityCardFrontImage,
			&i.FidelityCardBackImage,
			&i.FidelityCardPointImage,
			&i.FidelityCardMaxPoints,
			&i.FinalDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMyPrograms = `-- name: GetMyPrograms :many
SELECT id, title, description, fidelity_card_front_image, fidelity_card_back_image, fidelity_card_point_image, fidelity_card_max_points, final_date, active_links, owner_id, created_at FROM "program" WHERE owner_id = $1
`

func (q *Queries) GetMyPrograms(ctx context.Context, ownerID pgtype.Int4) ([]Program, error) {
	rows, err := q.db.Query(ctx, getMyPrograms, ownerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Program
	for rows.Next() {
		var i Program
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.FidelityCardFrontImage,
			&i.FidelityCardBackImage,
			&i.FidelityCardPointImage,
			&i.FidelityCardMaxPoints,
			&i.FinalDate,
			&i.ActiveLinks,
			&i.OwnerID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, name, photo, auth_provider, credits, birth_date, gender, user_role, created_at FROM "user" WHERE email = $1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Photo,
		&i.AuthProvider,
		&i.Credits,
		&i.BirthDate,
		&i.Gender,
		&i.UserRole,
		&i.CreatedAt,
	)
	return i, err
}

const getUserById = `-- name: GetUserById :one
SELECT id, email, name, photo, auth_provider, credits, birth_date, gender, user_role, created_at FROM "user" WHERE id = $1
`

func (q *Queries) GetUserById(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Name,
		&i.Photo,
		&i.AuthProvider,
		&i.Credits,
		&i.BirthDate,
		&i.Gender,
		&i.UserRole,
		&i.CreatedAt,
	)
	return i, err
}

const updateUserRole = `-- name: UpdateUserRole :exec
UPDATE "user" SET user_role = $1 WHERE id = $2
`

type UpdateUserRoleParams struct {
	UserRole UserRole
	ID       int32
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.Exec(ctx, updateUserRole, arg.UserRole, arg.ID)
	return err
}
